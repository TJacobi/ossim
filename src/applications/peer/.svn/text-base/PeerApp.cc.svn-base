//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see http://www.gnu.org/licenses/.
// 

#include "PeerApp.h"
#include "IChurnGenerator.h"
#include "UDPControlInfo_m.h"
#include "UDPPacket.h"
#include <IPAddressResolver.h>
#include "InterfaceTableAccess.h"
#include "IPv4InterfaceData.h"
#include <vector>

Define_Module(PeerApp);

#include "ActivePeerTable.h"
#include "AppCommon.h"
//#include "PeerStrmMsg_m.h"
//#include "PeerStreamingMessage_m.h"
//#include "PeerStreamingMessage.h"
#include "MeshPeerStreamingPacket_m.h"
#include "BufferMap.h"

long int PeerApp::instanceCount = 0;

PeerApp::PeerApp()
    : m_joined (false), m_scheduling_started(false)
{
    // TODO Auto-generated constructor stub
    ++instanceCount;

    timer_getJoinTime = timer_join = timer_keepAlive = timer_chunkScheduling = NULL;
}

PeerApp::~PeerApp() {
    // TODO Auto-generated destructor stub

    // Cancel all scheduled events
    if (timer_getJoinTime)      delete cancelEvent(timer_getJoinTime);
    if (timer_join)             delete cancelEvent(timer_join);
    if (timer_keepAlive)        delete cancelEvent(timer_keepAlive);
    if (timer_chunkScheduling)  delete cancelEvent(timer_chunkScheduling);

    /*
     * Both have issues:
     * undisposed object: (MeshBufferMapPacket) SimplePeerNetwork.peer[0].peerApp.MESH_PEER_BUFFER_MAP -- check module destructor
     *
     */
    /*
    cancelAndDelete(timer_getJoinTime);
    cancelAndDelete(timer_join);
    cancelAndDelete(timer_keepAlive);
    cancelAndDelete(timer_chunkScheduling);
    */

    if (m_videoBuffer != NULL) delete m_videoBuffer;

}

void PeerApp::initialize(int stage)
{
    if (stage == 1)
    {
        // appID = instanceCount;
        // param_keepAliveInterval = par("keepAliveInterval");

        // Data collection for module validation purposes
        r_countBM.setName("BM_count");

        // Timers
        timer_getJoinTime       = new cMessage("MESH_PEER_TIMER_GET_JOIN_TIME");
        timer_join              = new cMessage("MESH_PEER_TIMER_JOIN");
        timer_keepAlive         = new cMessage("MESH_PEER_TIMER_KEEP_ALIVE");
        timer_chunkScheduling   = new cMessage("MESH_PEER_TIMER_CHUNK_SCHEDULING");
    }
    else if (stage == 2)
    {
        localPort   = par("localPort");
        destPort    = par("destPort");

        param_bufferMapInterval             = par("bufferMapInterval");
        param_chunkSchedulingInterval       = par("chunkSchedulingInterval");
        param_nNeighbor_SchedulingStart     = par("nNeighbor_SchedulingStart");
        param_waitingTime_SchedulingStart   = par("waitingTime_SchedulingStart");

        int bufferMapSize_second    = par("bufferMapSize");
        int videoStreamBitRate      = par("videoStreamBitRate");
        int chunkSize               = par("chunkSize");

        m_videoStreamChunkRate = videoStreamBitRate / chunkSize;
        m_bufferMapSize_chunk = bufferMapSize_second * m_videoStreamChunkRate;

        // !!!!!!!!!!!!!! IMPORTANT !!!!!!!!!!!!!!!!!
        m_schedulingWindowSize = m_bufferMapSize_chunk;

        m_videoBuffer = new VideoStreamBuffer(m_bufferMapSize_chunk);

        WATCH(m_videoStreamChunkRate);

//        const char *destAddrs = par("destAddresses");
//        cStringTokenizer tokenizer(destAddrs);
//        const char *token;
//        while ((token = tokenizer.nextToken())!=NULL)
//            destAddresses.push_back(IPAddressResolver().resolve(token));
    }
    else if (stage == 3)
    {
        bindToPort(localPort);

        // old way to obtain the proposed arrival time
//        cMessage *message = new cMessage("MESH_PEER_TIMER_JOIN");
//        message->setKind(TIMER_MESH_GET_ARRIVAL_TIME);
//
//        scheduleAt(simTime() + par("startTime").doubleValue(), message);

        cModule *temp = simulation.getModuleByPath("churnModerator");
        // IChurnGenerator *churn = check_and_cast<IChurnGenerator *>(temp);
        churn = check_and_cast<IChurnGenerator *>(temp);

        temp = simulation.getModuleByPath("activePeerTable");
        aptable = check_and_cast<ActivePeerTable *>(temp);

//        scheduleAt(simTime() + churn->getArrivalTime(), new cMessage("MESH_PEER_TIMER_JOIN"));
//        scheduleAt(simTime() + par("startTime").doubleValue(), new cMessage("MESH_PEER_TIMER_GET_JOIN_TIME"));
        scheduleAt(simTime() + par("startTime").doubleValue(), timer_getJoinTime);
    }

}

void PeerApp::handleMessage(cMessage *msg)
{
    Enter_Method("PeerApp::handleMessage");

//    EV << "@handleMessage: getKind = " << msg->getKind() << endl;

    if (msg->isSelfMessage())
    {
        handleTimerMessage(msg);
    }
    else
    {
        processPacket(PK(msg));
//        handleExternalMessage(msg);
        EV << "packet processed at peer!" << endl;
    }


}

void PeerApp::handleTimerMessage(cMessage *msg)
{
//    Enter_Method("handleTimerMessage(msg)");

    if (msg == timer_getJoinTime)
    {
        EV << "in get_arrival_time" << endl;
        scheduleAt(simTime() + churn->getArrivalTime(), timer_join);
    }
    else if (msg == timer_join)
    {
        join();
    }
    else if (msg == timer_keepAlive)
    {
        // Schedule the next KEEP_ALIVE timer
        if (m_joined == true)
        {
            scheduleAt(simTime()+param_keepAliveInterval, timer_keepAlive);
        }

        //        EV << msg->getName() << endl;
        sendKeepAliveMsgToNeighbor();
    }
    else if (msg == timer_chunkScheduling)
    {
        chunkScheduling();

        // Schedule for the next chunk scheduling
        scheduleAt(simTime()+param_keepAliveInterval, timer_chunkScheduling);
    }


/*    if (opp_strcmp(msg->getName(), "MESH_PEER_TIMER_GET_JOIN_TIME") == 0)
    {
        EV << "in get_arrival_time" << endl;
        scheduleAt(simTime() + churn->getArrivalTime(), new cMessage("MESH_PEER_TIMER_JOIN"));
    }
    else if (opp_strcmp(msg->getName(), "MESH_PEER_TIMER_JOIN") == 0)
    {
        join();
    }
    else if (opp_strcmp(msg->getName(), "MESH_PEER_TIMER_KEEP_ALIVE") == 0)
    {
        // Schedule the next KEEP_ALIVE timer
        if (m_joined == true)
        {
            cMessage * keepAliveTimer = new cMessage("MESH_PEER_TIMER_KEEP_ALIVE");
            scheduleAt(simTime()+param_keepAliveInterval, keepAliveTimer);
        }

        //        EV << msg->getName() << endl;
        sendKeepAliveMsgToNeighbor();
    }
    else if (opp_strcmp(msg->getName(), "MESH_PEER_TIMER_CHUNK_SCHEDULING") == 0)
    {

        scheduleAt(simTime()+param_keepAliveInterval, new cMessage("MESH_PEER_TIMER_CHUNK_SCHEDULING"));
    }*/

    //delete msg;
}


void PeerApp::handleExternalMessage(cMessage *pkt)
{}

void PeerApp::processPacket(cPacket *pkt)
{
    Enter_Method("processPacket(pkt)");

    // -- Get the address of the source node of the Packet
    UDPControlInfo *controlInfo = check_and_cast<UDPControlInfo *>(pkt->getControlInfo());
    IPvXAddress sourceAddress = controlInfo->getSrcAddr();

    PeerStreamingPacket *appMsg = check_and_cast<PeerStreamingPacket *>(pkt);

    // EV << "appMsg->getMsgType() =" << appMsg->getMsgType() << endl;
    if (appMsg->getOverlayType() == MESH_STREAMING_OVERLAY)
    {
        MeshPeerStreamingPacket *meshMsg = check_and_cast<MeshPeerStreamingPacket *>(appMsg);
        switch (meshMsg->getPacketType())
        {
            case MESH_PARTNERSHIP:
            {
                // EV << "case MESH_PARTNERSHIP" << endl;
                MeshPartnershipPacket *pMsg = check_and_cast<MeshPartnershipPacket *>(appMsg);

                // EV << "pMsg->getCommand() = " << pMsg->getCommand() << endl;
                if (pMsg->getCommand() == CMD_MESH_PARTNERSHIP_ACCEPT)
                {
                    // EV << "register myself!" << endl;
                    processAcceptResponse(pMsg);

                    chunkScheduling();
                }
                else if (pMsg->getCommand() == CMD_MESH_PARTNERSHIP_REQUEST)
                {
                    acceptJoinRequest(pMsg);
                }
                break;
            }
            case MESH_BUFFER_MAP:
            {
                // EV << "received BufferMap packet! ---------" << endl;
                // -- Module validation
                // r_countBM.record(1);
                /*
                MeshBufferMapPacket *bmPkt = check_and_cast<MeshBufferMapPacket *>(appMsg);
                int countOne = 0;
                for (unsigned int i = 0; i < bmPkt->getBufferMapArraySize(); i++)
                {
                    countOne += bmPkt->getBufferMap(i)==true?1:0;

                }
                r_countBM.record(countOne);
                */

                // -- Cast to the BufferMap packet
                MeshBufferMapPacket *bmPkt = check_and_cast<MeshBufferMapPacket *>(appMsg);

                // -- Map the BufferMap Packet into the BufferMap object
                BufferMap *bm_temp = new BufferMap(m_bufferMapSize_chunk);
                bm_temp->readBufferMapPacket(bmPkt);

                // Update the neighborList with the new Buffermap
                int ret = neighborList.updateStoredBufferMap(sourceAddress, bm_temp);

                if (ret != RVALUE_NO_ERROR)
                {
                    // meaning a something wrong, since peer receives bufferMap from a non-neighbor peer
                    // TODO:
                    throw cException("Peer receives bufferMap from a non-neighbor peer");
                }

                // -- Scheduling
                if (m_scheduling_started == false)
                {
                    if (shouldStartChunkScheduling() == true)
                    {
                        initializeSchedulingWindow();
                        chunkScheduling();
                        m_scheduling_started = true;
                        // Schedule for the next chunk scheduling
                        scheduleAt(simTime() + param_chunkSchedulingInterval, timer_chunkScheduling);
                    }

                }
                break;
            }
            case MESH_KEEP_ALIVE:
            {
//                MeshKeepAliveMessage *kaMsg = check_and_cast<MeshKeepAliveMessage *>(appMsg);
                processKeepAliveMessage(meshMsg);
                EV << "Keep Alive message received from " << endl;
                break;
            }
            default:
            {
                //delete pkt;
                break;
            }
        } // switch
    }
    else // Tree overlay (later on ...)
    {

    }

    delete pkt;
}

void PeerApp::sendKeepAliveMsgToNeighbor()
{
//    NeighborList::iterator iter;
    std::vector<IPvXAddress> nList = neighborList.getNeighborList();
    std::vector<IPvXAddress>::iterator iter;
    for (iter = nList.begin(); iter != nList.end(); ++iter)
    {
        MeshKeepAlivePacket *keepAliveMsg = new MeshKeepAlivePacket("MESH_PEER_KEEP_ALIVE");
//        EV << "sending messasge to " << *iter << endl;
        sendToUDP(keepAliveMsg, localPort, *iter, destPort);
    }
}

void PeerApp::processKeepAliveMessage(cPacket *pkt)
{
    UDPControlInfo *controlInfo = check_and_cast<UDPControlInfo *>(pkt->getControlInfo());
    IPvXAddress nbrAddress = controlInfo->getSrcAddr();

    // The following command is no more valid, because of the modification of the code
    //    neighborList.updateKeepAliveTimestamp(nbrAddress, simTime().dbl());
}

void PeerApp::processAcceptResponse(cPacket *pkt)
{
    Enter_Method("processAcceptResponse()");

    // Register myself to the ActivePeerList
    if (m_joined == false)
    {
        // -- Get the IP address of myself
        IInterfaceTable *inet_ift;
        inet_ift = InterfaceTableAccess().get();

        if (inet_ift->getNumInterfaces() < 2)
        {
            throw cException("not enough number of interfaces at the Video Source");
            return;
        }

        IPvXAddress myAddress(inet_ift->getInterface(1)->ipv4Data()->getIPAddress());
        // EV << "IP address of peer node: " << sourceAddress << endl;

        cModule *temp = simulation.getModuleByPath("activePeerTable");
        ActivePeerTable *aptable = check_and_cast<ActivePeerTable *>(temp);

        aptable->addPeerAddress(myAddress);
        aptable->printActivePeerTable();

        m_joined = true;
        m_firstJoinTime = simTime().dbl();

        // Start scheduling /now/ or at some later time


        // Schedule the KEEP_ALIVE timer
        //cMessage * kaTimer = new cMessage("MESH_PEER_TIMER_KEEP_ALIVE");
        //scheduleAt(simTime() + par("keepAliveInterval").doubleValue(), kaTimer);

    }

    // Add the remote peer to the NeighborList
    // addToNeighborList(pkt);
    UDPControlInfo *controlInfo = check_and_cast<UDPControlInfo *>(pkt->getControlInfo());
    IPvXAddress reqPeerAddress = controlInfo->getSrcAddr();

    // 2. Store the address into its neighbor list
    neighborList.addNeighborAddress(reqPeerAddress);

    // Debug:
    neighborList.printNeighborList();
    //delete pkt;
}
/*
void PeerApp::acceptJoinRequest(cPacket *pkt)
{
    Enter_Method("acceptJoinRequest");

    // 1. Get the IP-address of the peer
//    UDPPacket *pkt = check_and_cast<UDPPacket *>(msg);
    UDPControlInfo *controlInfo = check_and_cast<UDPControlInfo *>(pkt->getControlInfo());
    IPvXAddress sourceAddress = controlInfo->getSrcAddr();
//    int srcPort = controlInfo->getSrcPort();

    // 2. Store the address into its neighbor list
    neighborList.addNeighborAddress(sourceAddress);

    // 3. Check if this is the first neighbor, if YES --> trigger the Heartbeat module (to periodically start sending the hearbeat)
    if (neighborList.getSizeNeighborList() == 1)
    {
//        startSendingHeartbeat();
    }
    delete pkt;
}
*/
void PeerApp::acceptJoinRequest(cPacket *pkt)
{
    Enter_Method("acceptJoinRequest(pkt)");

    // 1. Get the IP-address of the peer
    UDPControlInfo *controlInfo = check_and_cast<UDPControlInfo *>(pkt->getControlInfo());
    IPvXAddress reqPeerAddress = controlInfo->getSrcAddr();

    // 2. Store the address into its neighbor list
    neighborList.addNeighborAddress(reqPeerAddress);

    // Debug:
    neighborList.printNeighborList();

    // 3. Send the explicit ACCEPT request
    MeshPartnershipPacket *acceptPkt = new MeshPartnershipPacket("MESH_PEER_JOIN");
    acceptPkt->setPacketType(MESH_PARTNERSHIP);
    acceptPkt->setCommand(CMD_MESH_PARTNERSHIP_ACCEPT);
    sendToUDP(acceptPkt, localPort, reqPeerAddress, destPort);

    // 4. Check if this is the first neighbor, if YES --> trigger the Heartbeat module (to periodically start sending the hearbeat)
    if (neighborList.getSize() == 1)
    {
//        startSendingHeartbeat();
    }

    //delete pkt;
}

void PeerApp::addToNeighborList(cPacket *pkt)
{
    Enter_Method("addToNeighborList(pkt)");

    // 1. Get the IP-address of the peer
    UDPControlInfo *controlInfo = check_and_cast<UDPControlInfo *>(pkt->getControlInfo());
    IPvXAddress reqPeerAddress = controlInfo->getSrcAddr();

    // 2. Store the address into its neighbor list
    neighborList.addNeighborAddress(reqPeerAddress);
}

void PeerApp::startSendingHeartbeat()
{
    Enter_Method("startSendingHeartbeat()");

    std::vector<IPvXAddress> updateList;
    updateList = neighborList.getNeighborList();

    std::vector<IPvXAddress>::iterator it;
    for (it=updateList.begin(); it != updateList.end(); ++it)
    {
        cPacket *heartbeatPkt = new cPacket("MESH_PEER_KEEP_ALIVE");
        sendToUDP(heartbeatPkt, localPort, *it, destPort);
    }
}

void PeerApp::join()
{
    Enter_Method("join()");

    long int nActivePeer = aptable->getNumActivePeer();
    EV << "Number of Active Peers: " << nActivePeer << endl;

    for (int i=0; i<nActivePeer; ++i)
    {
        IPvXAddress addressRandPeer = aptable->getARandPeer();

        //cPacket *pkt_join_req = new cPacket("MESH_PEER_JOIN"); // old: cPacket
        MeshPartnershipPacket *pkt_join_req = new MeshPartnershipPacket("MESH_PEER_JOIN");
        pkt_join_req->setPacketType(MESH_PARTNERSHIP);
        pkt_join_req->setCommand(CMD_MESH_PARTNERSHIP_REQUEST);
        // pkt_join_req->setKind(MESH_PEER_JOIN_REQUEST);
        sendToUDP(pkt_join_req, localPort, addressRandPeer, destPort);

    } // end of for(i)
}

void PeerApp::initializeSchedulingWindow()
{

}

bool PeerApp::shouldStartChunkScheduling(void)
{
    if (simTime().dbl() - m_firstJoinTime >= param_waitingTime_SchedulingStart
            || neighborList.getSize() >= param_nNeighbor_SchedulingStart)
    {
        return true;
    }

    return false;
}

bool PeerApp::should_be_requested(void)
{
    return true;
}

/*
 * Depending on _strategy_ which is applied, the schedulingWindows will be initialized accordingly
 */
void initializeSchedulingWindow(void)
{
    // Relative lag


    // Absolute lag
}

/*
 * This function is a _wrapper_ for the specific chunk scheduling algorithm
 */
void PeerApp::chunkScheduling(void)
{
    // The logic of the following lines were moved into another function, shouldStartChunkScheduling()
    // !!!
    // -- Get the number of neighbors
    // if exceeding some threshold (default = 1) --> start scheduling
    // if (neighborList.getSize() < param_nNeighbor_SchedulingStart)
    //     return;

    if (true)
    {
        return;
    }

    randomScheduling();

    //scheduleAt(simTime() + param_chunkSchedulingInterval, timer_chunkScheduling);
}


void PeerApp::randomScheduling(void)
{
    for (SEQUENCE_NUMBER_T seq_num = m_winStart_seqNum; seq_num < m_winEnd_seqNum; ++seq_num)
    {
        if (m_videoBuffer->isInBuffer(seq_num) == false)
        {
            if (should_be_requested() == false)
            {
                continue;
            }

            // Get list of neighbors which has this chunk in their buffer map
            std::vector<IPvXAddress> holderList;
            neighborList.getHolderList(seq_num, holderList);
            int nHolder = holderList.size();

            // if there is at least one neighbor
            if (nHolder > 0)
            {
                int index = 0;
                if (nHolder == 1)
                {
                    index = 0;
                }
                else
                {
                    index = (int)(rand() % holderList.size());
                } // if

            } // if (nHolder > 0)

        } // end of if(inBuffer)
    } // end of for
}

