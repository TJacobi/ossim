//
// Generated file, do not edit! Created by opp_msgc 4.2 from applications/common/messages/MeshPeerStreamingPacket.msg.
//

#ifndef _MESHPEERSTREAMINGPACKET_M_H_
#define _MESHPEERSTREAMINGPACKET_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0402
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include <PeerStreamingPacket_m.h>
// }}



/**
 * Enum generated from <tt>applications/common/messages/MeshPeerStreamingPacket.msg</tt> by opp_msgc.
 * <pre>
 * enum MeshPeerStreamingPacketType
 * {
 *     MESH_PARTNERSHIP    = 0;
 *     MESH_KEEP_ALIVE     = 1;
 *     MESH_BUFFER_MAP     = 2;
 *     MESH_CHUNK_REQUEST  = 3;
 *     MESH_CHUNK_REPLY    = 4;
 *     MESH_VIDEO_CHUNK    = 5;
 * }
 * </pre>
 */
enum MeshPeerStreamingPacketType {
    MESH_PARTNERSHIP = 0,
    MESH_KEEP_ALIVE = 1,
    MESH_BUFFER_MAP = 2,
    MESH_CHUNK_REQUEST = 3,
    MESH_CHUNK_REPLY = 4,
    MESH_VIDEO_CHUNK = 5
};

/**
 * Enum generated from <tt>applications/common/messages/MeshPeerStreamingPacket.msg</tt> by opp_msgc.
 * <pre>
 * enum MeshPartnershipCommandType
 * {
 *     CMD_MESH_PARTNERSHIP_REQUEST    = 0;
 *     CMD_MESH_PARTNERSHIP_ACCEPT     = 1;
 *     CMD_MESH_PARTNERSHIP_REJECT     = 2;
 * }
 * </pre>
 */
enum MeshPartnershipCommandType {
    CMD_MESH_PARTNERSHIP_REQUEST = 0,
    CMD_MESH_PARTNERSHIP_ACCEPT = 1,
    CMD_MESH_PARTNERSHIP_REJECT = 2
};

/**
 * Class generated from <tt>applications/common/messages/MeshPeerStreamingPacket.msg</tt> by opp_msgc.
 * <pre>
 * packet MeshPeerStreamingPacket extends PeerStreamingPacket
 * {
 *     overlayType = MESH_STREAMING_OVERLAY;
 *     short packetType @getter(getPacketType) @setter(setPacketType) @enum(MeshPeerStreamingPacketType) ;
 * }
 * </pre>
 */
class MeshPeerStreamingPacket : public ::PeerStreamingPacket
{
  protected:
    short packetType_var;

  private:
    void copy(const MeshPeerStreamingPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MeshPeerStreamingPacket&);

  public:
    MeshPeerStreamingPacket(const char *name=NULL, int kind=0);
    MeshPeerStreamingPacket(const MeshPeerStreamingPacket& other);
    virtual ~MeshPeerStreamingPacket();
    MeshPeerStreamingPacket& operator=(const MeshPeerStreamingPacket& other);
    virtual MeshPeerStreamingPacket *dup() const {return new MeshPeerStreamingPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual short getPacketType() const;
    virtual void setPacketType(short packetType);
};

inline void doPacking(cCommBuffer *b, MeshPeerStreamingPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MeshPeerStreamingPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/common/messages/MeshPeerStreamingPacket.msg</tt> by opp_msgc.
 * <pre>
 * packet MeshPartnershipPacket extends MeshPeerStreamingPacket
 * {
 *     packetType = MESH_PARTNERSHIP;
 *     short command enum(MeshPartnershipCommandType);
 * }
 * </pre>
 */
class MeshPartnershipPacket : public ::MeshPeerStreamingPacket
{
  protected:
    short command_var;

  private:
    void copy(const MeshPartnershipPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MeshPartnershipPacket&);

  public:
    MeshPartnershipPacket(const char *name=NULL, int kind=0);
    MeshPartnershipPacket(const MeshPartnershipPacket& other);
    virtual ~MeshPartnershipPacket();
    MeshPartnershipPacket& operator=(const MeshPartnershipPacket& other);
    virtual MeshPartnershipPacket *dup() const {return new MeshPartnershipPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual short getCommand() const;
    virtual void setCommand(short command);
};

inline void doPacking(cCommBuffer *b, MeshPartnershipPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MeshPartnershipPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/common/messages/MeshPeerStreamingPacket.msg</tt> by opp_msgc.
 * <pre>
 * packet MeshKeepAlivePacket extends MeshPeerStreamingPacket
 * {
 *     packetType = MESH_KEEP_ALIVE;
 * }
 * </pre>
 */
class MeshKeepAlivePacket : public ::MeshPeerStreamingPacket
{
  protected:

  private:
    void copy(const MeshKeepAlivePacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MeshKeepAlivePacket&);

  public:
    MeshKeepAlivePacket(const char *name=NULL, int kind=0);
    MeshKeepAlivePacket(const MeshKeepAlivePacket& other);
    virtual ~MeshKeepAlivePacket();
    MeshKeepAlivePacket& operator=(const MeshKeepAlivePacket& other);
    virtual MeshKeepAlivePacket *dup() const {return new MeshKeepAlivePacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, MeshKeepAlivePacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MeshKeepAlivePacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/common/messages/MeshPeerStreamingPacket.msg</tt> by opp_msgc.
 * <pre>
 * packet MeshBufferMapPacket extends MeshPeerStreamingPacket
 * {
 *     packetType = MESH_BUFFER_MAP;
 *     
 *     
 *     
 *     long bmStart_seqNum     @getter(getBmStartSeqNum)   @setter(setBmStartSeqNum);
 *     long bmEnd_seqNum       @getter(getBmEndSeqNum)     @setter(setBmEndSeqNum);
 *     long head_seqNum        @getter(getHeadSeqNum)      @setter(setHeadSeqNum);
 *     
 *     bool bufferMap[];
 * }
 * </pre>
 */
class MeshBufferMapPacket : public ::MeshPeerStreamingPacket
{
  protected:
    long bmStart_seqNum_var;
    long bmEnd_seqNum_var;
    long head_seqNum_var;
    bool *bufferMap_var; // array ptr
    unsigned int bufferMap_arraysize;

  private:
    void copy(const MeshBufferMapPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MeshBufferMapPacket&);

  public:
    MeshBufferMapPacket(const char *name=NULL, int kind=0);
    MeshBufferMapPacket(const MeshBufferMapPacket& other);
    virtual ~MeshBufferMapPacket();
    MeshBufferMapPacket& operator=(const MeshBufferMapPacket& other);
    virtual MeshBufferMapPacket *dup() const {return new MeshBufferMapPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual long getBmStartSeqNum() const;
    virtual void setBmStartSeqNum(long bmStart_seqNum);
    virtual long getBmEndSeqNum() const;
    virtual void setBmEndSeqNum(long bmEnd_seqNum);
    virtual long getHeadSeqNum() const;
    virtual void setHeadSeqNum(long head_seqNum);
    virtual void setBufferMapArraySize(unsigned int size);
    virtual unsigned int getBufferMapArraySize() const;
    virtual bool getBufferMap(unsigned int k) const;
    virtual void setBufferMap(unsigned int k, bool bufferMap);
};

inline void doPacking(cCommBuffer *b, MeshBufferMapPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MeshBufferMapPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/common/messages/MeshPeerStreamingPacket.msg</tt> by opp_msgc.
 * <pre>
 * packet MeshChunkRequestPacket extends MeshPeerStreamingPacket
 * {
 *     packetType = MESH_CHUNK_REQUEST;
 *     
 *     long seqNum_mapStart     @getter(getSeqNumMapStart)     @setter(setSeqNumMapStart);
 *     long seqNum_mapEnd       @getter(getSeqNumMapEnd)       @setter(setSeqNumMapEnd);
 *     long seqNum_mapHead      @getter(getSeqNumMapHead)      @setter(setSeqNumMapHead);
 *     
 *     bool requestMap[];
 * }
 * </pre>
 */
class MeshChunkRequestPacket : public ::MeshPeerStreamingPacket
{
  protected:
    long seqNum_mapStart_var;
    long seqNum_mapEnd_var;
    long seqNum_mapHead_var;
    bool *requestMap_var; // array ptr
    unsigned int requestMap_arraysize;

  private:
    void copy(const MeshChunkRequestPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MeshChunkRequestPacket&);

  public:
    MeshChunkRequestPacket(const char *name=NULL, int kind=0);
    MeshChunkRequestPacket(const MeshChunkRequestPacket& other);
    virtual ~MeshChunkRequestPacket();
    MeshChunkRequestPacket& operator=(const MeshChunkRequestPacket& other);
    virtual MeshChunkRequestPacket *dup() const {return new MeshChunkRequestPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual long getSeqNumMapStart() const;
    virtual void setSeqNumMapStart(long seqNum_mapStart);
    virtual long getSeqNumMapEnd() const;
    virtual void setSeqNumMapEnd(long seqNum_mapEnd);
    virtual long getSeqNumMapHead() const;
    virtual void setSeqNumMapHead(long seqNum_mapHead);
    virtual void setRequestMapArraySize(unsigned int size);
    virtual unsigned int getRequestMapArraySize() const;
    virtual bool getRequestMap(unsigned int k) const;
    virtual void setRequestMap(unsigned int k, bool requestMap);
};

inline void doPacking(cCommBuffer *b, MeshChunkRequestPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MeshChunkRequestPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>applications/common/messages/MeshPeerStreamingPacket.msg</tt> by opp_msgc.
 * <pre>
 * packet MeshVideoChunkPacket extends MeshPeerStreamingPacket
 * {
 *     packetType = MESH_VIDEO_CHUNK;
 *     long seqNumber @getter(getSeqNumber) @setter(setSeqNumber);
 *     double timeStamp @getter(getTimeStamp) @setter(setTimeStamp);
 * }
 * </pre>
 */
class MeshVideoChunkPacket : public ::MeshPeerStreamingPacket
{
  protected:
    long seqNumber_var;
    double timeStamp_var;

  private:
    void copy(const MeshVideoChunkPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MeshVideoChunkPacket&);

  public:
    MeshVideoChunkPacket(const char *name=NULL, int kind=0);
    MeshVideoChunkPacket(const MeshVideoChunkPacket& other);
    virtual ~MeshVideoChunkPacket();
    MeshVideoChunkPacket& operator=(const MeshVideoChunkPacket& other);
    virtual MeshVideoChunkPacket *dup() const {return new MeshVideoChunkPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual long getSeqNumber() const;
    virtual void setSeqNumber(long seqNumber);
    virtual double getTimeStamp() const;
    virtual void setTimeStamp(double timeStamp);
};

inline void doPacking(cCommBuffer *b, MeshVideoChunkPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MeshVideoChunkPacket& obj) {obj.parsimUnpack(b);}


#endif // _MESHPEERSTREAMINGPACKET_M_H_
