//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see http://www.gnu.org/licenses/.
//

cplusplus {{
#include <PeerStreamingPacket_m.h>
//#include "AppCommon.h"
}}

class PeerStreamingPacket;

enum MeshPeerStreamingPacketType
{
    MESH_PARTNERSHIP    = 0;
    MESH_KEEP_ALIVE     = 1;
    MESH_BUFFER_MAP     = 2;
    MESH_CHUNK_REQUEST  = 3;
    MESH_CHUNK_REPLY    = 4;
    MESH_VIDEO_CHUNK    = 5;
}

enum MeshPartnershipCommandType
{
    CMD_MESH_PARTNERSHIP_REQUEST    = 0;
    CMD_MESH_PARTNERSHIP_ACCEPT     = 1;
    CMD_MESH_PARTNERSHIP_REJECT     = 2;
}

//
// Base class for all messages handled by protocol's modules
//
// @author Giang Nguyen
// @see 
//

//packet MeshPeerStreamingPacket extends PeerStreamingMessage
//{
////    int stateType enum(StatType) = MAINTENANCE_STAT; // message type for stats
//}

packet MeshPeerStreamingPacket extends PeerStreamingPacket
{
    overlayType = MESH_STREAMING_OVERLAY;
    short packetType @getter(getPacketType) @setter(setPacketType) @enum(MeshPeerStreamingPacketType) ;
}


packet MeshPartnershipPacket extends MeshPeerStreamingPacket
{
    packetType = MESH_PARTNERSHIP;
    short command enum(MeshPartnershipCommandType);
}

packet MeshKeepAlivePacket extends MeshPeerStreamingPacket
{
    packetType = MESH_KEEP_ALIVE;
}

packet MeshBufferMapPacket extends MeshPeerStreamingPacket
{
    packetType = MESH_BUFFER_MAP;
    // long idStart; // should be of type SEQUENCE_NUMBER_T
    // long idEnd; // should be of type SEQUENCE_NUMBER_T
    
    long bmStart_seqNum     @getter(getBmStartSeqNum)   @setter(setBmStartSeqNum);
    long bmEnd_seqNum       @getter(getBmEndSeqNum)     @setter(setBmEndSeqNum);
    long head_seqNum        @getter(getHeadSeqNum)      @setter(setHeadSeqNum);
    
    bool bufferMap[];
}

packet MeshChunkRequestPacket extends MeshPeerStreamingPacket
{
    packetType = MESH_CHUNK_REQUEST;
    
    long seqNum_mapStart     @getter(getSeqNumMapStart)     @setter(setSeqNumMapStart);
    long seqNum_mapEnd       @getter(getSeqNumMapEnd)       @setter(setSeqNumMapEnd);
    long seqNum_mapHead      @getter(getSeqNumMapHead)      @setter(setSeqNumMapHead);
    
    bool requestMap[];
}

//packet MeshChunkReplyPacket extends MeshPeerStreamingPacket
//{
//    packetType = MESH_CHUNK_REPLY;
//}

packet MeshVideoChunkPacket extends MeshPeerStreamingPacket
{
    packetType = MESH_VIDEO_CHUNK;
    long seqNumber @getter(getSeqNumber) @setter(setSeqNumber);
    double timeStamp @getter(getTimeStamp) @setter(setTimeStamp);
}



