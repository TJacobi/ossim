//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see http://www.gnu.org/licenses/.
// 

#include "VideoStreamBuffer.h"

#define _VERSION_1 1
#define _VERSION_2 2
#define _VERSION_3 3
#define BUFFER_IMPL_VERSION _VERSION_3

Define_Module(VideoStreamBuffer);

VideoStreamBuffer::VideoStreamBuffer()
{

}

VideoStreamBuffer::VideoStreamBuffer(int size)
//    : m_id_bufferStart(-1), m_id_bufferEnd(-1), m_bufferSize(-1)
// : m_id_bufferStart(-1), m_id_bufferEnd(-1) // because of the modification in class implementation
: m_bufferStart_seqNum(-1), m_bufferEnd_seqNum(-1)
{
    // TODO Auto-generated constructor stub
    m_streamBuffer.resize(size);
    m_bufferSize = size;
    std::vector<STREAM_BUFFER_ELEMENT_T>::iterator iter;

    // Creating enough number of elements for the buffer
    // each element "points" to a NULL packet
    for(iter = m_streamBuffer.begin(); iter != m_streamBuffer.end(); ++ iter)
    {
        STREAM_BUFFER_ELEMENT_T &elem = *iter;
        elem.m_chunk = NULL;
    }

    // Debug
    r_index.setName("bm_index");
}

VideoStreamBuffer::~VideoStreamBuffer() {
    // TODO Auto-generated destructor stub
    std::vector<STREAM_BUFFER_ELEMENT_T>::iterator iter;

    for(iter = m_streamBuffer.begin(); iter != m_streamBuffer.end(); ++ iter)
    {
        STREAM_BUFFER_ELEMENT_T &elem = *iter;
        if (elem.m_chunk != NULL)
        {
            // TODO: release memory -- DONE
            // elem.m_packet->release_reference();
            delete elem.m_chunk;
        }
    }
}

void VideoStreamBuffer::initialize(int stage)
{
    if (stage != 3)
    {
        return;
    }

    // TODO: more content to come
    int size = -1;
//    VideoSourceApp *src = dynamic_cast<VideoSourceApp *>(getParentModule());
//    PeerApp *peer = dynamic_cast<PeerApp *>(getParentModule());
//    if (peer)
//        size = peer->get
//    if (src)
//    {

//    }
//    else

    //int size = getParentModule()->getBufferMapSize();
    m_streamBuffer.resize(size);
    m_bufferSize = size;
    std::vector<STREAM_BUFFER_ELEMENT_T>::iterator iter;

    // Creating enough number of elements for the buffer
    // each element "points" to a NULL packet
    for(iter = m_streamBuffer.begin(); iter != m_streamBuffer.end(); ++ iter)
    {
        STREAM_BUFFER_ELEMENT_T &elem = *iter;
        elem.m_chunk = NULL;
    }

    // Debug
    r_index.setName("bm_index");
}

void VideoStreamBuffer::handleMessage(cMessage *)
{
    // EV << "VideoStreamBuffer doesn't process messages!" << endl;
    throw cException("VideoStreamBuffer doesn't process messages!");
}

/*
// Version which uses queue for the StreamBuffer
void VideoStreamBuffer::insertPacket(MeshVideoChunkPacket *packet, SIM_TIME_T current_time)
{
    // create the buffer element from packet & current_time

    // push the buffer_element to the queue (m_streamBuffer)

    // Check if the current size of buffer is larger than the defined size
    // - if yes: remove the buffer_element at the other side of the queue
}
*/

void VideoStreamBuffer::insertPacket(MeshVideoChunkPacket *packet, SIM_TIME_T current_time)
{
    long seq_num = packet->getSeqNumber();
    STREAM_BUFFER_ELEMENT_T & elem = m_streamBuffer[seq_num % m_bufferSize];
    if (elem.m_chunk != NULL)
    {
        // TODO: release allocated memory (or simply, delete the chunk)
        // elem.m_chunk->release_reference();

        delete elem.m_chunk;
    }
    elem.m_chunk = packet;
    elem.m_recved_time = current_time;

#if (BUFFER_IMPL_VERSION == _VERSION_1)
    if (seq_num > m_id_bufferEnd)
    {
        // because of modification in class implementation
        m_id_bufferEnd = seq_num;
        m_id_bufferStart = std::max(0L, m_id_bufferEnd - m_bufferSize + 1);
    }
#elif (BUFFER_IMPL_VERSION == _VERSION_2)
    if (seq_num > m_bufferEnd_seqNum)
    {
        m_bufferEnd_seqNum = seq_num;
        m_bufferStart_seqNum = std::max(0L, m_bufferEnd_seqNum - m_bufferSize + 1);
    }
#elif (BUFFER_IMPL_VERSION == _VERSION_3)
    if (seq_num > m_head_received_seqNum)
    {
        /*
        // because of modification in class implementation
        m_id_bufferEnd = seq_num;
        m_id_bufferStart = std::max(0L, m_id_bufferEnd - m_bufferSize + 1);
        */

        m_head_received_seqNum = seq_num;
        m_bufferStart_seqNum = std::max(0L, m_head_received_seqNum - m_bufferSize + 1);
        m_bufferEnd_seqNum = (m_bufferStart_seqNum == 0) ? m_bufferSize : m_head_received_seqNum;
    }
#endif

    //if (seq_num > m_id_bufferEnd)
    // if (seq_num > m_bufferEnd_seqNum)
    {
        /*
        // because of modification in class implementation
        m_id_bufferEnd = seq_num;
        m_id_bufferStart = std::max(0L, m_id_bufferEnd - m_bufferSize + 1);
        */

        m_bufferEnd_seqNum = seq_num;
        m_bufferStart_seqNum = std::max(0L, m_bufferEnd_seqNum - m_bufferSize + 1);
    }
    // TODO: verification for the removal of this line!!!
    // packet->add_reference();
}


// TODO: verification!!!
bool VideoStreamBuffer::isInBuffer(SEQUENCE_NUMBER_T seq_num)
{
    // Browse through the queue?
    STREAM_BUFFER_ELEMENT_T &elem = m_streamBuffer[seq_num % m_streamBuffer.size()];
    /*
     * Return TRUE only if the elem points to a packet AND the seq_num of the packet is correct
     */
    return (elem.m_chunk != NULL && elem.m_chunk->getSeqNumber() == seq_num);
}

// TODO: verification!!!
SIM_TIME_T VideoStreamBuffer::getReceivedTime(SEQUENCE_NUMBER_T seq_num)
{
    STREAM_BUFFER_ELEMENT_T &elem = m_streamBuffer[seq_num % m_bufferSize];
    if (elem.m_chunk != NULL && elem.m_chunk->getSeqNumber() == seq_num)
    {
        return elem.m_recved_time;
    }
    return (SIM_TIME_T)-1;
}

// TODO: verification!!!
MeshVideoChunkPacket * VideoStreamBuffer::getChunk(SEQUENCE_NUMBER_T seq_num)
{
    STREAM_BUFFER_ELEMENT_T &elem = m_streamBuffer[seq_num % m_bufferSize];
    if (elem.m_chunk != NULL && elem.m_chunk->getSeqNumber() == seq_num)
    {
        return elem.m_chunk;
    }
    return NULL;
}

// TODO: verification!!!
STREAM_BUFFER_ELEMENT_T & VideoStreamBuffer::getBufferElement(SEQUENCE_NUMBER_T seq_num)
{
    return m_streamBuffer[seq_num % m_bufferSize];

}

void VideoStreamBuffer::captureVideoStreamBuffer(BufferMap *bm)
{
    std::vector<STREAM_BUFFER_ELEMENT_T>::iterator iter;
    for (iter = m_streamBuffer.begin(); iter != m_streamBuffer.end(); ++iter)
    {
        // if the element stores no chunk
        if (iter->m_chunk == NULL)
            continue;

        // if the id of the packet at that element is too "old"
        // if (iter->m_chunk->getSeqNumber() < m_id_bufferStart)
        if (iter->m_chunk->getSeqNumber() < m_bufferStart_seqNum)
            continue;

        // int idx = iter->m_chunk->getSeqNumber() - m_id_bufferStart;
        int idx = iter->m_chunk->getSeqNumber() - m_bufferStart_seqNum;
        bm->setElementByOffset(idx, true); // TODO: find out the problem of this line
    }
}

void VideoStreamBuffer::printStatus()
{
    std::vector<STREAM_BUFFER_ELEMENT_T>::iterator iter;

    // Creating enough number of elements for the buffer
    // each element "points" to a NULL packet
    for(iter = m_streamBuffer.begin(); iter != m_streamBuffer.end(); ++ iter)
    {
        STREAM_BUFFER_ELEMENT_T &elem = *iter;
        short bit = -1;
        bit = (elem.m_chunk != NULL)?1:0;
        EV << bit << " ";
    }
    EV << endl;
}

void VideoStreamBuffer::fillBufferMapPacket(MeshBufferMapPacket *bmPkt)
{
    bmPkt->setBufferMapArraySize(m_bufferSize);
    bmPkt->setBmStartSeqNum(m_bufferStart_seqNum);
    bmPkt->setBmEndSeqNum(m_bufferEnd_seqNum);

    for (int i = 0; i < m_bufferSize; i++)
    {
        bmPkt->setBufferMap(i, false);
    }

    // this block has problem
    std::vector<STREAM_BUFFER_ELEMENT_T>::iterator iter;
    for (iter = m_streamBuffer.begin(); iter != m_streamBuffer.end(); ++iter)
    {
        // if the element stores no chunk
        if (iter->m_chunk == NULL)
            continue;

        // if the id of the packet at that element is too "old"
        // if (iter->m_chunk->getSeqNumber() < m_id_bufferStart)
        if (iter->m_chunk->getSeqNumber() < m_bufferStart_seqNum)
            continue;

        // int idx = iter->m_chunk->getSeqNumber() - m_id_bufferStart;
        int idx = iter->m_chunk->getSeqNumber() - m_bufferStart_seqNum;
        bmPkt->setBufferMap(idx, true);
//        r_index.record(iter->m_chunk->getSeqNumber());
//        r_index.record(m_id_bufferStart);
//        r_index.record(1);

//        int idx = iter->m_chunk->getSeqNumber() - m_id_bufferStart;
//        bm->setElement(idx, true); // TODO: find out the problem of this line
    }

}
