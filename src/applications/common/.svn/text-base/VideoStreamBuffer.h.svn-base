//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see http://www.gnu.org/licenses/.
// 

#ifndef VIDEOSTREAMBUFFER_H_
#define VIDEOSTREAMBUFFER_H_

#include <queue>
#include "MeshPeerStreamingPacket_m.h"
#include "AppCommon.h"
#include "BufferMap.h"

typedef struct __STRM_BUF_ELEM{
    __STRM_BUF_ELEM() : m_chunk(NULL) {};

    MeshVideoChunkPacket *m_chunk;
    SEQUENCE_NUMBER_T m_recved_time;
} STREAM_BUFFER_ELEMENT_T;

class VideoStreamBuffer : public cSimpleModule {
//class VideoStreamBuffer {
public:
    VideoStreamBuffer(int size);
    VideoStreamBuffer();
    virtual ~VideoStreamBuffer();

protected:
  virtual int numInitStages() const  {return 4;}
  virtual void initialize(int stage);

  // Raises an error.
  virtual void handleMessage(cMessage *);

public:
    /*
    inline void setID_bufferStart(SEQUENCE_NUMBER_T val) { m_id_bufferStart = val; }
    inline SEQUENCE_NUMBER_T getID_bufferStart() { return m_id_bufferStart; }
    inline void setID_bufferEnd(SEQUENCE_NUMBER_T val) { m_id_bufferEnd = val; }
    inline SEQUENCE_NUMBER_T getID_bufferEnd() { return m_id_bufferEnd; }
    */
    inline void setBufferStartSeqNum(SEQUENCE_NUMBER_T val) { m_bufferStart_seqNum = val; }
    inline void setBufferEndSeqNum(SEQUENCE_NUMBER_T val) { m_bufferEnd_seqNum = val; }
    inline void setHeadReceivedSeqNum(SEQUENCE_NUMBER_T val) { m_head_received_seqNum = val; }

    inline SEQUENCE_NUMBER_T getBufferStartSeqNum(void) { return m_bufferStart_seqNum; }
    inline SEQUENCE_NUMBER_T getBufferEndSeqNum(void) { return m_bufferEnd_seqNum; }
    inline SEQUENCE_NUMBER_T getHeadReceivedSeqNum(void) { return m_head_received_seqNum; }

    inline void setSize(int size) { m_bufferSize = size; }
    inline int getSize() { return m_bufferSize; }

    void insertPacket(MeshVideoChunkPacket *packet, SIM_TIME_T current_time);
    bool isInBuffer(SEQUENCE_NUMBER_T seq_num);
    SIM_TIME_T getReceivedTime(SEQUENCE_NUMBER_T seq_num);
    MeshVideoChunkPacket *getChunk(SEQUENCE_NUMBER_T seq_num);
    STREAM_BUFFER_ELEMENT_T & getBufferElement(SEQUENCE_NUMBER_T seq_num);
    void captureVideoStreamBuffer(BufferMap *bm);
    void fillBufferMapPacket(MeshBufferMapPacket *bmPkt);


    // Debug
    void printStatus();

private:
    // old version which uses queue
    //    std::queue<STREAM_BUFFER_ELEMENT_T> m_streamBuffer;

    std::vector<STREAM_BUFFER_ELEMENT_T> m_streamBuffer;
    // sequence numbers
    SEQUENCE_NUMBER_T m_bufferStart_seqNum; // staring sequence number of the buffer
    SEQUENCE_NUMBER_T m_bufferEnd_seqNum;   // ending sequence number of the buffer
    SEQUENCE_NUMBER_T m_head_received_seqNum; // largest sequence number of chunks received so far

    int m_bufferSize;

// Debug
private:
    cOutVector r_index;
};

#endif /* VIDEOSTREAMBUFFER_H_ */
