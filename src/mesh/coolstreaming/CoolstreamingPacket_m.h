//  
// =============================================================================
// OSSIM : A Generic Simulation Framework for Overlay Streaming
// =============================================================================
//
// (C) Copyright 2012-2013, by Giang Nguyen (P2P, TU Darmstadt) and Contributors
//
// Project Info: http://www.p2p.tu-darmstadt.de/research/ossim
//
// OSSIM is free software: you can redistribute it and/or modify it under the 
// terms of the GNU General Public License as published by the Free Software 
// Foundation, either version 3 of the License, or (at your option) any later 
// version.
//
// OSSIM is distributed in the hope that it will be useful, but WITHOUT ANY 
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
// A PARTICULAR PURPOSE. See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along with 
// this program. If not, see <http://www.gnu.org/licenses/>.

// -----------------------------------------------------------------------------
// CoolstreamingPacket_m.h
// -----------------------------------------------------------------------------
// (C) Copyright 2012-2013, by Giang Nguyen (P2P, TU Darmstadt) and Contributors
//
// Contributors: Thorsten Jacobi;
// Code Reviewers: Giang;
// ------------------------------------------------------------------------------
//

//
// Generated file, do not edit! Created by opp_msgc 4.2 from mesh/coolstreaming/CoolstreamingPacket.msg.
//

#ifndef _COOLSTREAMINGPACKET_M_H_
#define _COOLSTREAMINGPACKET_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0402
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include <MeshPeerStreamingPacket_m.h>
// }}



/**
 * Enum generated from <tt>mesh/coolstreaming/CoolstreamingPacket.msg</tt> by opp_msgc.
 * <pre>
 * enum CoolstreamingPacketType
 * {
 * 	COOLSTREAMING_BUFFER_MAP = 0;
 * 	COOLSTREAMING_PARTNERSHIP_REQUEST = 1;
 * 	COOLSTREAMING_PARTNERSHIP_ACCEPT = 2;
 * 	COOLSTREAMING_PARTNERSHIP_REVOKE = 3;
 * 	COOLSTREAMING_CHUNK = 4;
 * }
 * </pre>
 */
enum CoolstreamingPacketType {
    COOLSTREAMING_BUFFER_MAP = 0,
    COOLSTREAMING_PARTNERSHIP_REQUEST = 1,
    COOLSTREAMING_PARTNERSHIP_ACCEPT = 2,
    COOLSTREAMING_PARTNERSHIP_REVOKE = 3,
    COOLSTREAMING_CHUNK = 4
};

/**
 * Class generated from <tt>mesh/coolstreaming/CoolstreamingPacket.msg</tt> by opp_msgc.
 * <pre>
 * packet CoolstreamingPacket extends MeshPeerStreamingPacket
 * {
 *     packetGroup = PACKET_GROUP_MESH_OVERLAY;
 *     
 *     short packetType     @getter(getPacketType) @setter(setPacketType) @enum(CoolstreamingPacketType) ;     
 * }
 * </pre>
 */
class CoolstreamingPacket : public ::MeshPeerStreamingPacket
{
  protected:
    short packetType_var;

  private:
    void copy(const CoolstreamingPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CoolstreamingPacket&);

  public:
    CoolstreamingPacket(const char *name=NULL, int kind=0);
    CoolstreamingPacket(const CoolstreamingPacket& other);
    virtual ~CoolstreamingPacket();
    CoolstreamingPacket& operator=(const CoolstreamingPacket& other);
    virtual CoolstreamingPacket *dup() const {return new CoolstreamingPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual short getPacketType() const;
    virtual void setPacketType(short packetType);
};

inline void doPacking(cCommBuffer *b, CoolstreamingPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CoolstreamingPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>mesh/coolstreaming/CoolstreamingPacket.msg</tt> by opp_msgc.
 * <pre>
 * packet CoolstreamingBufferMapPacket extends CoolstreamingPacket
 * {
 * 	packetType = COOLSTREAMING_BUFFER_MAP;
 * 	
 * 	int sequenceNumbers[];
 * 	bool subscribe[];
 * }
 * </pre>
 */
class CoolstreamingBufferMapPacket : public ::CoolstreamingPacket
{
  protected:
    int *sequenceNumbers_var; // array ptr
    unsigned int sequenceNumbers_arraysize;
    bool *subscribe_var; // array ptr
    unsigned int subscribe_arraysize;

  private:
    void copy(const CoolstreamingBufferMapPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CoolstreamingBufferMapPacket&);

  public:
    CoolstreamingBufferMapPacket(const char *name=NULL, int kind=0);
    CoolstreamingBufferMapPacket(const CoolstreamingBufferMapPacket& other);
    virtual ~CoolstreamingBufferMapPacket();
    CoolstreamingBufferMapPacket& operator=(const CoolstreamingBufferMapPacket& other);
    virtual CoolstreamingBufferMapPacket *dup() const {return new CoolstreamingBufferMapPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual void setSequenceNumbersArraySize(unsigned int size);
    virtual unsigned int getSequenceNumbersArraySize() const;
    virtual int getSequenceNumbers(unsigned int k) const;
    virtual void setSequenceNumbers(unsigned int k, int sequenceNumbers);
    virtual void setSubscribeArraySize(unsigned int size);
    virtual unsigned int getSubscribeArraySize() const;
    virtual bool getSubscribe(unsigned int k) const;
    virtual void setSubscribe(unsigned int k, bool subscribe);
};

inline void doPacking(cCommBuffer *b, CoolstreamingBufferMapPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CoolstreamingBufferMapPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>mesh/coolstreaming/CoolstreamingPacket.msg</tt> by opp_msgc.
 * <pre>
 * packet CoolstreamingPartnershipRequestPacket extends CoolstreamingPacket
 * {
 * 	packetType = COOLSTREAMING_PARTNERSHIP_REQUEST;
 * }
 * </pre>
 */
class CoolstreamingPartnershipRequestPacket : public ::CoolstreamingPacket
{
  protected:

  private:
    void copy(const CoolstreamingPartnershipRequestPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CoolstreamingPartnershipRequestPacket&);

  public:
    CoolstreamingPartnershipRequestPacket(const char *name=NULL, int kind=0);
    CoolstreamingPartnershipRequestPacket(const CoolstreamingPartnershipRequestPacket& other);
    virtual ~CoolstreamingPartnershipRequestPacket();
    CoolstreamingPartnershipRequestPacket& operator=(const CoolstreamingPartnershipRequestPacket& other);
    virtual CoolstreamingPartnershipRequestPacket *dup() const {return new CoolstreamingPartnershipRequestPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, CoolstreamingPartnershipRequestPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CoolstreamingPartnershipRequestPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>mesh/coolstreaming/CoolstreamingPacket.msg</tt> by opp_msgc.
 * <pre>
 * packet CoolstreamingPartnershipAcceptPacket extends CoolstreamingPacket
 * {
 * 	packetType = COOLSTREAMING_PARTNERSHIP_ACCEPT;
 * }
 * </pre>
 */
class CoolstreamingPartnershipAcceptPacket : public ::CoolstreamingPacket
{
  protected:

  private:
    void copy(const CoolstreamingPartnershipAcceptPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CoolstreamingPartnershipAcceptPacket&);

  public:
    CoolstreamingPartnershipAcceptPacket(const char *name=NULL, int kind=0);
    CoolstreamingPartnershipAcceptPacket(const CoolstreamingPartnershipAcceptPacket& other);
    virtual ~CoolstreamingPartnershipAcceptPacket();
    CoolstreamingPartnershipAcceptPacket& operator=(const CoolstreamingPartnershipAcceptPacket& other);
    virtual CoolstreamingPartnershipAcceptPacket *dup() const {return new CoolstreamingPartnershipAcceptPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, CoolstreamingPartnershipAcceptPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CoolstreamingPartnershipAcceptPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>mesh/coolstreaming/CoolstreamingPacket.msg</tt> by opp_msgc.
 * <pre>
 * packet CoolstreamingPartnershipRevokePacket extends CoolstreamingPacket
 * {
 * 	packetType = COOLSTREAMING_PARTNERSHIP_REVOKE;
 * }
 * </pre>
 */
class CoolstreamingPartnershipRevokePacket : public ::CoolstreamingPacket
{
  protected:

  private:
    void copy(const CoolstreamingPartnershipRevokePacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CoolstreamingPartnershipRevokePacket&);

  public:
    CoolstreamingPartnershipRevokePacket(const char *name=NULL, int kind=0);
    CoolstreamingPartnershipRevokePacket(const CoolstreamingPartnershipRevokePacket& other);
    virtual ~CoolstreamingPartnershipRevokePacket();
    CoolstreamingPartnershipRevokePacket& operator=(const CoolstreamingPartnershipRevokePacket& other);
    virtual CoolstreamingPartnershipRevokePacket *dup() const {return new CoolstreamingPartnershipRevokePacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, CoolstreamingPartnershipRevokePacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CoolstreamingPartnershipRevokePacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>mesh/coolstreaming/CoolstreamingPacket.msg</tt> by opp_msgc.
 * <pre>
 * packet CoolstreamingChunkPacket extends CoolstreamingPacket
 * {
 * 	packetType = COOLSTREAMING_CHUNK;
 * 	int sequenceNumber  @getter(getSequenceNumber) @setter(setSequenceNumber);
 * }
 * </pre>
 */
class CoolstreamingChunkPacket : public ::CoolstreamingPacket
{
  protected:
    int sequenceNumber_var;

  private:
    void copy(const CoolstreamingChunkPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CoolstreamingChunkPacket&);

  public:
    CoolstreamingChunkPacket(const char *name=NULL, int kind=0);
    CoolstreamingChunkPacket(const CoolstreamingChunkPacket& other);
    virtual ~CoolstreamingChunkPacket();
    CoolstreamingChunkPacket& operator=(const CoolstreamingChunkPacket& other);
    virtual CoolstreamingChunkPacket *dup() const {return new CoolstreamingChunkPacket(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSequenceNumber() const;
    virtual void setSequenceNumber(int sequenceNumber);
};

inline void doPacking(cCommBuffer *b, CoolstreamingChunkPacket& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CoolstreamingChunkPacket& obj) {obj.parsimUnpack(b);}


#endif // _COOLSTREAMINGPACKET_M_H_
